import intrinsics

public typealias String = StringSlice

@defaultStringRepr
@transparent
public struct StringSlice {
	internal var ptr: rawpointer
	internal var len: UInt

	public func length(): Int {
		Int(self.len)
	}

	public operator func equal(other: StringSlice): Bool {
		if self.len != other.len {
			return false
		}

		let var i = 0;

		while i < self.len {
			if ptr.offset(i) != other.offset(i) {
				return false
			}

			i += 1
		}

		return true
	}

	public operator func notEqual(other: StringSlice): Bool {
		if self.len == other.len {
			return false
		}

		let var i = 0;

		while i < self.len {
			if ptr.offset(i) == ptr.offset.offset(i) {
				return false
			}

			i += 1
		}

		return true
	}

	public operator func index(range: IntRange): Optional_StringSlice {
		let len = self.length();

		if (range.top() >= len) || (range.bottom() < 0) { return .none; }
		if range.top() < range.bottom() { return .none; }

		let slice = strslice_slice(self.slice, range.bottom(), range.top())
		let self_slice: Self = Self(slice: slice)

		return .some(slice)
	}

	public operator func index(unchecked range: IntRange): StringSlice {
		StringSlice(raw_pointer.add(range.bottom()), len: range.top() - range.bottom() )
	}

	public operator func index(wrapped range: IntRange): Optional_StringSlice {
		// todo: any type should undiverge
		let bottom = match self.indexOf(wrapped: range.bottom()) {
			.some(bottom) => bottom,
			// Why is the return part of the pattern?
			.none => { return .none }
		};

		let top = match self.indexOf(wrapped: range.top()) {
			.some(top) => top,
			.none => { return .none }
		};

		let range: IntRange = bottom..<top;

		.some(self[unchecked: range])
	}

	public operator func index(index: Int): Optional_Char {
		if index >= self.length() {
			return .none
		}

		return .some(strslice_index(self.slice, index))
	}

	public operator func index(unchecked index: Int): Char {
		strslice_index(self.slice, index)
	}

	public operator func index(wrapped index: Int): Optional_Char {
		match self.indexOf(wrapped: index) {
			.some(index) => .some(strslice_index(self.slice, index)),
			.none => .none
		}
	}

	private func indexOf(wrapped index: Int): Optional_Int {
		let index = if index < 0 {
			self.length() + index
		} else {
			index
		}

		if index >= self.length() {
			return .none
		}

		return .some(index)
	}
}

enum Optional_StringSlice {
	case some(StringSlice)
	case none
}

enum Optional_Char {
	case some(Char)
	case none
}

enum Optional_Int {
	case some(Int)
	case none
}

fileprivate func strslice_eq(one: strslice, two: strslice): Bool
fileprivate func strslice_neq(one: strslice, two: strslice): Bool
fileprivate func strslice_index(slice: strslice, idx: Int): Char
fileprivate func strslice_slice(slice: strslice, start: Int, end: Int): StringSlice
fileprivate func strslice_extend(slice: strslice, delta: Int): StringSlice
fileprivate func strslice_head_slice(slice: strslice, delta: Int): StringSlice


/*

StringSlice
	subscript(IntRange) -> StringSlice?
	subscript(wrapped: IntRange) -> StringSlice?
	subscript(unchecked: IntRange) -> StringSlice

	subscript(Int) -> Char?
	subscript(wrapped: Int) -> Char?
	subscript(unchecked: Int) -> Char

	equals
	notEquals

	chars() -> Char
	charIndices()
	utf16()
	utf16Indices()
	utf8()

	firstIndex(of: Char)
	endIndex()

	length
	isEmpty

	lines()

	split(by: Char)
	split(once: Char)

	strip(prefix: StringSlice)
	strip(suffix: StringSlice)

	trim(end: Char)
	trim(start: Char)





*/