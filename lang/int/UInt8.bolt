import intrinsics

@transparent
public struct UInt8 /*: IntegerLiteralRepresentable */ {
	public static let min: Self = 0x0
	public static let max: Self = 0xff

	public var repr: i8

	public operator func add(b: Self): Self {
		Self(repr: integer8Add(self.repr, b.repr) )
	}

	public operator func sub(b: Self): Self {
		Self(repr: integer8Sub(self.repr, b.repr) )
	}

	public operator func mul(b: Self): Self {
		Self (repr: integer8Mul(self.repr, b.repr) )
	}

	public operator func div(b: Self): Self {
		Self (repr: integer8Div(self.repr, b.repr) )
	}

	public operator func mod(b: Self): Self {
		Self (repr: integer8Rem(self.repr, b.repr) )
	}


	public operator func bitOr(b: Self): Self {
		Self (repr: integer8Or(self.repr, b.repr) )
	}

	public operator func bitXor(b: Self): Self {
		Self (repr: integer8Xor(self.repr, b.repr) )
	}

	public operator func bitAnd(b: Self): Self {
		Self (repr: integer8And(self.repr, b.repr) )
	}

	public operator func shiftLeft(b: Self): Self {
		Self (repr: integer8Shl(self.repr, b.repr) )
	}

	public operator func shiftRight(b: Self): Self {
		Self (repr: integer8Shr(self.repr, b.repr) )
	}


	public operator func equalual(b: Self): Bool {
		Bool (repr: integer8CmpEq(self.repr, b.repr) )
	}

	public operator func notEqual(b: Self): Bool {
		Bool (repr: integer8CmpNeq(self.repr, b.repr) )
	}

	public operator func lessThan(b: Self): Bool {
		Bool (repr: integer8CmpLt(self.repr, b.repr) )
	}

	public operator func greaterThan(b: Self): Bool {
		Bool (repr: integer8CmpGt(self.repr, b.repr) )
	}

	public operator func lessThanEq(b: Self): Bool {
		Bool (repr: integer8CmpLte(self.repr, b.repr) )
	}

	public operator func greaterThanEq(b: Self): Bool {
		Bool (repr: integer8CmpGte(self.repr, b.repr) )
	}

	
	public operator func negate(): Self {
		Self (repr: integer8Negate(self.repr) )
	}

	public operator func invert(): Self {
		Self (repr: integer8Invert(self.repr) )
	}

	public operator func unit(): Self {
		self
	}

	public operator func openRange(upper: Self): UInt8Range {
		UInt8Range(low: self, high: upper + 1)
	}

	public operator func closedRange(upper: Self): UInt8Range {
		UInt8Range(low: self, high: upper)
	}

	public static func bitcastInt8(i: Int8): Self {
		Self (repr: i.repr )
	}

	public static func truncUInt16(i: UInt16): Self {
		Self (repr: integer16Trunc8(i.repr) )
	}

	public static func truncUInt32(i: UInt32): Self {
		Self (repr: integer32Trunc8(i.repr) )
	}

	public static func truncUInt64(i: UInt64): Self {
		Self (repr: integer64Trunc8(i.repr) )
	}

	public static func truncInt16(i: Int16): Self {
		Self (repr: integer16Trunc8(i.repr) )
	}

	public static func truncInt32(i: Int32): Self {
		Self (repr: integer32Trunc8(i.repr) )
	}

	public static func truncInt64(i: Int64): Self {
		Self (repr: integer64Trunc8(i.repr) )
	}
}

public struct UInt8Range {
	fileprivate var low: UInt8
	fileprivate var high: UInt8
}

public func for(range: UInt8Range, f: func (UInt8)) {
	if range.low != range.high {
		f(range.low);
		for(range.low + 1..<range.high, f)
	}
}